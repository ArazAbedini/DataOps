input {
  kafka {
    bootstrap_servers => "kafka:9092"  
    topics => ["json_topic"]
    codec => "json"
    consumer_threads => 4                        
    group_id => "logstash-test-pipeline"        
    auto_offset_reset => "earliest"              # Start from beginning if no offset
  }
}

filter {
  # Remove unwanted fields including Kafka metadata
  mutate {
    remove_field => [
      "junk",
      "extra_note",
      "extra_debug",
      "extra_field",
      "@version",
      "[@metadata][kafka]"
    ]
  }

  # Standardize name field (use either name or full_name)
  if [full_name] {
    mutate {
      replace => { "name" => "%{[full_name]}" }
      remove_field => ["full_name"]
    }
  }

  # Clean name field
  mutate {
    gsub => ["name", "^[ \t]+|[ \t]+$", ""]
  }
  
  # Set name to null if empty
  if [name] =~ /^\s*$/ {
    mutate {
      replace => { "name" => null }
    }
  }

  # Handle ID field
  if ![id] or !([id] =~ /^[0-9]+$/) {
    drop {}
  } else {
    mutate {
      convert => { "id" => "integer" }
    }
  }
  # Standardize timestamp
  if [timestamp] =~ /^\d{10,13}$/ {
    # Handle epoch timestamps
    ruby {
      code => "
        ts = event.get('timestamp').to_i
        ts = ts / 1000 if ts > 9999999999
        event.set('timestamp', Time.at(ts).utc.strftime('%Y-%m-%dT%H:%M:%SZ'))
      "
    }
  }
  else if [timestamp] {
    # Handle string timestamps
    mutate {
      gsub => [
        "timestamp", "(\d{4})/(\d{2})/(\d{2}) ", "\1-\2-\3T",
        "timestamp", "(\d{2})-(\d{2})-(\d{4}) ", "\3-\2-\1T",
        "timestamp", "T(\d{2}:\d{2})$", "T\1:00Z",
        "timestamp", " ", "T"
      ]
    }
    date {
      match => ["timestamp", 
        "yyyy-MM-dd'T'HH:mm:ss",
        "yyyy-MM-dd'T'HH:mm:ss.SSSZ",
        "yyyy-MM-dd'T'HH:mm:ssZ",
        "yyyy-MM-dd'T'HH:mmZ",
        "ISO8601"
      ]
      target => "@timestamp"
      timezone => "UTC"
    }
    mutate {
      replace => { "timestamp" => "%{+yyyy-MM-dd'T'HH:mm:ssZ}" }
      remove_field => ["@timestamp"]
    }
  }

  # Standardize active field to boolean
  if [active] {
    mutate {
      lowercase => ["active"]
    }
    if [active] in ["true", "t", "yes", "y", "1"] {
      mutate {
        replace => { "active" => true }
      }
    } else if [active] in ["false", "f", "no", "n", "0"] {
      mutate {
        replace => { "active" => false }
      }
    } else {
      mutate {
        replace => { "active" => false }
      }
    }
  }

  # Add pipeline metadata
  mutate {
    add_field => {
      "[@metadata][pipeline]" => "test_pipeline"
      "[@metadata][processed_at]" => "%{+yyyy-MM-dd'T'HH:mm:ssZ}"
    }
  }

  # Validate required fields
  if ![id] or [id] == "" or [id] =~ /[^0-9a-zA-Z.]/ {
    drop {}
  }
  if ![timestamp] or [timestamp] == "" {
    drop {}
  }
}

output {
  elasticsearch {
    hosts => ["http://elasticsearch:9200"]  
    index => "test_pipeline"                   
    document_id => "%{id}"                     
    action => "index"                          
  }

  stdout {
    codec => rubydebug
  }

}